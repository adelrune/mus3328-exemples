// Variables globales

// Ces variables servent à l'encodage en SLIP.
const byte END=192;
const byte ESC=219; 
const byte ESC_END=220;
const byte ESC_ESC=221;

const int outPins[] = { 3, 5, 9 }; // Les pins utilisées en sortie (PWM).
const int numOutPins = 3; // Le nombre de pins (taille de outPins).

// La taille maximum d'un paquet SLIP.  Ce nombre doit être plus grande que le
// paquet le plus grand attendu.
byte slipPacket[256]; // Cet array contiendra le paquet SLIP reçu.
int packetIndex = 0;  // L'index du paquet SLIP reçu.  Cette valeur sera
                      // incrémentée à chaque octet reçu.  Elle sera remise à
                      // zéro quand un paquet SLIP sera complet.

void setup() {
  Serial.begin(115200);
  for( int i=0 ; i < numOutPins ; i++) {
    pinMode(outPins[i], OUTPUT); // Les outPins sont initialisées en OUTPUT.
  }
}

void loop() {
  int sensor = 0;
  int size = 0;

  Serial.write(END);   // On commence le paquet.
  // Ce n'est pas obligatoire, mais préférable en SLIP.
  
  // if (Serial.available() > 0) {
  //   size = SLIPbuildPacket( &slipPacket[0], &packetIndex );

    
  //   for (int i = 0 ; i < size ; i++) { // On prend chaque octet du paquet
  //                                      // reçu.
  //     // analogWrite(outPins[i], slipPacket[i]); // On écrit les valeurs sur
  //     Serial.write(slipPacket[i]);
      
  //     // les pins PWM  (pour faire varier les LED).
  //   }
  // }

  while (Serial.available()) {
    Serial.write(Serial.read());
  };

  // Lire l'entrée analogique et envoyer la valeur sur le port série.
  // sensor = analogRead(0);

  // SLIPSerialWrite(sensor >> 8 ); // envoyer le MSB (premier octet).
  // SLIPSerialWrite(sensor & 255 ); // envoyer le LSB (deuxième octet).
  Serial.println("endOfPaquet");
  // Serial.write(END);   // On termine le paquet.

  // On attend un peu avant de faire une nouvelle lecture des entrées analogiques.
  delay(500);
}

int SLIPbuildPacket (byte *slipPacket, int * packetIndex) {
  byte b;
  int size = 0;
  b = Serial.read();
  if (b == END) { // Si le paquet est complet,
    size = *packetIndex;
    *packetIndex = 0; // on remet l'index à zéro et
    return size; // on retourne la taille du paquet.
  } else {
    if ( b == ESC ) { // Si on lit un '219' (ESC),
      b = Serial.read(); // On lit l'octet suivant.
      if (b == ESC_END) { // Si c'est '220' (ESC_END),
        slipPacket[*packetIndex] = END; // on ajoute '192' au paquet.
      } else {
        if (b == ESC_ESC) { // Si c'est '221' (ESC_ESC),
          slipPacket[*packetIndex] = ESC; // on ajoute '219'.
        }
      }
    } else { // Si c'est un octet normal (pas '192' ni '219'),
      slipPacket[*packetIndex] = b; // on l'ajoute au paquet.
    }
    (*packetIndex)++; // On incrémente l'index du paquet.
    return 0; // On retourne 0 tant que le paquet n'est pas complet.
  }
}

// Fonction pour encoder en SLIP
void SLIPSerialWrite(int value){
  if(value == END){ 
    Serial.write(ESC);
    Serial.write(ESC_END);
    return;
  } else if(value == ESC) {  
    Serial.write(ESC);
    Serial.write(ESC_ESC);
    return;
  } else {
    Serial.write(value);
    return;
  }
}

